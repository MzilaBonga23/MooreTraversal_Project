package MooreTraversal;

import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;

public class BestFirst {
    PriorityQueue<State> stateQueue;
    String[][] swamp;
    int startPosition;
    boolean isSolution;
    String path ="";

    Comparator<State> comparator = new GreedyComparator(); // compares the priority of each state

    public BestFirst(String[][] lake,int start){
        startPosition = start;
        swamp = lake;
        if(lake != null && !isSolution){
            stateQueue = new PriorityQueue<>(comparator);
            stateQueue.add(new State(lake,start,0, lake[0].length));
            path += "("+startPosition+",0) ";
            traverse();
        }
        else{
            System.out.println("Couldn't find the swamp to navigate through!");
        }
    }

    public void traverse(){
        PriorityQueue<State> temp = new PriorityQueue<>(comparator);
        boolean deadEnd = false;
        while (!isSolution) {
            State current = stateQueue.poll();
            int i = current.positionI;
            int j = current.positionJ;
            if (i > 0) {
                State newState = new Print().copyBest(current.getSwamp(),current.positionI,current.positionJ,current.priority);
                newState.positionI--;
                newState.positionJ++;
                newState.priority = current.getSwamp()[0].length-1 - newState.positionJ;
                temp.add(newState); // creates the new state/frontier generated by current node/state
            }
            if (i < current.getSwamp().length) { // checks if it's not the last row
                State newState = new Print().copyBest(current.getSwamp(),current.positionI,current.positionJ,current.priority);
                newState.positionI++;
                newState.positionJ++;
                newState.priority = current.getSwamp()[0].length-1 - newState.positionJ;
                temp.add(newState);
            }
            if (j < current.getSwamp()[0].length) { // checks if it's not the last column
                State newState = new Print().copyBest(current.getSwamp(),current.positionI,current.positionJ,current.priority);
                newState.positionJ++;
                newState.priority = current.getSwamp()[0].length-1 - newState.positionJ;
                temp.add(newState);
            }
            while (temp.size() != 0){ // Ii is exploring the states generated above to find the right path
                State s = temp.poll();
                int row = s.positionI;
                int col = s.positionJ;
                if(s.getSwamp()[row][col].equals("D")){
                    stateQueue.add(s);
                    temp.clear();
                    path += "("+Integer.toString(row)+","+ Integer.toString(col)+ ") ";
                }
                else if(!s.getSwamp()[row][col].equals("D") && temp.size() == 0){
                    isSolution = false;
                    deadEnd = true;
                    break;
                }
                if(col== s.getSwamp()[0].length-1 && s.getSwamp()[row][col].equals("D")){
                    isSolution = true;
                }
            }
            if(deadEnd == true){
                break;
            }

        }
    }
    public String getPath(){
        return path;
    }
}
