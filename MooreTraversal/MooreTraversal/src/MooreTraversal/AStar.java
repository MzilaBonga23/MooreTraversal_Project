package MooreTraversal;

import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;

public class AStar {
    String [][] lake;
    PriorityQueue<State> statePriorityQueue;
    boolean isSolution = false;
    int entrance;
    String path = "";

    Comparator<State> comparator = new AStarComparator();

    public AStar(String[][] lake,int init){
        if(lake!=null && !isSolution){
            this.lake = lake;
            entrance = init;
            statePriorityQueue = new PriorityQueue<>(comparator);
            statePriorityQueue.add(new State(lake,entrance,0,lake[0].length,lake[0].length));
            path += "("+entrance+",0) ";
            traverse();
        }
        else if(!isSolution){
            System.out.println("No solution found");
        }
        else{
            System.out.println("Couldn't find the swamp!");
        }
    }

    public void traverse() {
        PriorityQueue<State> temp = new PriorityQueue<>(comparator);
        boolean deadEnd = false;
        while (!isSolution) {
            State current = statePriorityQueue.poll();
            int i = current.positionI;
            int j = current.positionJ;
            if (i > 0) {
                State newState = new Print().copyA(current.getSwamp(), current.positionI,
                        current.positionJ, current.priority, current.statePriority);
                newState.positionI--;
                newState.positionJ++;
                newState.priority = current.getSwamp()[0].length;
                newState.statePriority = 1;
                temp.add(newState); // creates the new state/frontier generated by current node/state
            }
            if (i < current.getSwamp().length) { // checks if it's not the last row
                State newState = new Print().copyA(current.getSwamp(), current.positionI,
                        current.positionJ, current.priority, current.statePriority);
                newState.positionI++;
                newState.positionJ++;
                newState.priority = current.getSwamp()[0].length; //f(n)= distance travelled + distance left
                newState.statePriority = 1;
                temp.add(newState);
            }
            if (j < current.getSwamp()[0].length) { // checks if it's not the last column
                State newState = new Print().copyA(current.getSwamp(), current.positionI,
                        current.positionJ, current.priority, current.statePriority);
                newState.positionJ++;
                newState.priority = current.getSwamp()[0].length;
                newState.statePriority = 2;
                temp.add(newState);
            }
            while (temp.size() != 0){ // It is exploring the states generated above to find the right path
                State s = temp.poll();
                int row = s.positionI;
                int col = s.positionJ;
                if(s.getSwamp()[row][col].equals("D")){
                    statePriorityQueue.add(s);
                    temp.clear();
                    path += "("+Integer.toString(row)+","+ Integer.toString(col)+ ") ";
                }
                if(col== s.getSwamp()[0].length-1 && s.getSwamp()[row][col].equals("D")){
                    isSolution = true;
                }
                else if(!s.getSwamp()[row][col].equals("D") && temp.size() == 0){
                    isSolution = false;
                    deadEnd = true;
                    break;
                }

            }
            if(deadEnd == true){
                break;
            }

        }
    }
    public String getPath(){
        return path;
    }

}
