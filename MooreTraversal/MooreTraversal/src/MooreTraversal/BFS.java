package MooreTraversal;

import java.util.LinkedList;
import java.util.Queue;

public class BFS {
    Queue<State> queue;
    boolean isSolution = false;  //checks if it's the desired solution
    int entrancePosition;
    String path = "";

    public BFS(String[][] lake,int i){
        entrancePosition = i;
        if(lake!=null && !isSolution) {
            queue = new LinkedList<>();
            queue.add(new State(lake,entrancePosition,0, null));
            path += "("+entrancePosition+",0) ";
            traverse();
        }
        else if(!isSolution){
            System.out.println("No solution found!");
        }
        else{
            System.out.println("Couldn't find the swamp to cross");
        }
    }

    void traverse(){

        Queue<State> temp = new LinkedList<>();
        boolean deadEnd = false;
        while (!isSolution){
            State current = queue.remove();
            int i = current.positionI;
            int j = current.positionJ;
            if(i>0){
                State state1 = new Print().copy1(current.getSwamp(), current.positionI, current.positionJ,current.parent);
                state1.positionI--;
                state1.positionJ++;
                temp.add(state1); // creates the new state/frontier generated by current node/state
            }
            if(j< current.getSwamp()[0].length){ // checks if it's not the last column
                State state2 = new Print().copy1(current.getSwamp(), current.positionI, current.positionJ,
                         current.parent);
                state2.positionJ++;
                temp.add(state2);
            }
            if(i<current.getSwamp().length){ // checks if it's not the last row
                State state3 = new Print().copy1(current.getSwamp(), current.positionI, current.positionJ, current.parent);
                state3.positionI++;
                state3.positionJ++;
                temp.add(state3);
            }
            while (!temp.isEmpty()){ // Ii is exploring the states generated above to find the right path
                State s = temp.remove();
                int row = s.positionI;
                int col = s.positionJ;
                if(s.getSwamp()[row][col].equals("D")){
                    queue.add(s);
                    temp.clear();
                    path += "("+Integer.toString(row)+","+ Integer.toString(col)+ ") ";
                }
                else if(!s.getSwamp()[row][col].equals("D") && temp.isEmpty()){
                    isSolution = false;
                    deadEnd = true;
                    break;
                }
                if(col== s.getSwamp()[0].length-1 && s.getSwamp()[row][col].equals("D")){
                    isSolution = true;
                }
            }
            if(deadEnd == true){
                break;
            }
        }
    }

    public String getPath(){
        return path;
    }
}
